# Lessons Overview

## Lesson 1
  - `task1.yml`: Given a sample YAML file, identify the different components (workflow name, events, jobs, steps).
  - `task2.yml`: Create a basic workflow that triggers on every push to the main branch and runs a shell command like echo "Hello, World!".

## Lesson 2
  - `task1.yml`: Create a workflow that runs a matrix build for a Node.js application across different Node.js versions.
  - `task2.yml`: Implement caching for npm dependencies in the workflow to optimize execution time.
  - `task3.yml`: Set up a conditional trigger to run a deployment job only on the main branch.

## Lesson 3
  - `task1.yml`: Create a simple workflow that includes a job with three steps: checking out the code, setting up the environment, and running a build command.
  - `task2.yml`: Modify the workflow to include environment variables and a secret.

## Lesson 4
  - `task1.yml`: Create a workflow that uses at least three different pre-built actions from the GitHub Marketplace.
  - `task2.yml`: Customize one of the actions by providing specific inputs and handling its outputs.

## Lesson 5
  - `task1.yml`: Create a custom GitHub Action that performs a specific task (e.g., greeting a user or running a shell command).
  - `task2.yml`: Test the action in a GitHub repository and publish it to the GitHub Marketplace.
    
## Lesson 6
  - `task1.yml`: Create a workflow that automates a scheduled task, uses parallel jobs, and implements caching to optimize performance.
  - `task1.yml`: Implement error handling and retry logic in a workflow that deploys an application.

## Lesson 7
  - `task1.yml`: Configure a GitHub Actions workflow with restricted permissions, secure secrets management, and code scanning. Ensure that the workflow adheres to best security practices.
  - `task2.yml`: Implement environment protection in a deployment workflow, requiring manual approval before deployment to production.
    
## Lesson 8
  - `task1.yml`: Design a workflow that includes parallel job execution, dependency caching, and proper version pinning. Ensure the workflow follows best practices for performance and maintenance.
  - `task2.yml`: Troubleshoot a failing workflow by enabling debug logging, reviewing logs, and implementing the necessary fixes to resolve the issue.

## Lesson 9
  - `task1.yml`: Create a GitHub Actions workflow that triggers a build in Jenkins and deploys the build artifact to an AWS environment using AWS CodePipeline.
